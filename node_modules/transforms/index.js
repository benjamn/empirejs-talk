var esprimaHarmony = require("esprima");
var recast = require("recast");
var types = recast.types;
var traverse = types.traverse;
var n = types.namedTypes;
var b = types.builders;
var isString = types.builtInTypes.string;

var recastOptions = {
  esprima: esprimaHarmony
};

function transformExpressionBody(node) {
  if (n.Function.check(node) && node.expression) {
    node.expression = false;
    node.body = b.blockStatement([b.returnStatement(node.body)]);
  }
}

function transformArrowFunction(node) {
  transformExpressionBody.call(this, node);

  if (n.ArrowFunctionExpression.check(node)) {
    var funExp = b.functionExpression(
      node.id, node.params, node.body,
      node.generator, node.expression
    );

    var bindExp = b.callExpression(
      b.memberExpression(funExp, b.identifier("bind"), false),
      [b.thisExpression()]
    );

    this.replace(bindExp);
  }
}

exports.transformArrowFunctions = function(source) {
  var ast = recast.parse(source, recastOptions);
  traverse(ast, transformArrowFunction);
  return recast.print(ast).code;
};

function mx(obj, prop) {
  return b.memberExpression(
    isString.check(obj) ? b.identifier(obj) : obj,
    isString.check(prop) ? b.identifier(prop) : prop,
    false
  );
}

function transformRestParameter(node) {
  transformExpressionBody.call(this, node);

  if (n.Function.check(node) && node.rest) {
    var sliceCallee = mx(mx(mx("Array", "prototype"), "slice"), "call");

    var sliceArgs = [
      b.identifier("arguments"),
      b.literal(node.params.length)
    ];

    var sliceCall = b.callExpression(sliceCallee, sliceArgs);

    var restVarDecl = b.variableDeclaration("var", [
      b.variableDeclarator(node.rest, sliceCall)
    ]);

    node.body.body.unshift(restVarDecl);
    node.rest = null;
  }

  transformArrowFunction.call(this, node);
}

exports.transformRestParameters = function(source) {
  var ast = recast.parse(source, recastOptions);
  traverse(ast, transformRestParameter);
  return recast.print(ast).code;
};
